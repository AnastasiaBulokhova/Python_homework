# Задача №17.
# Дан список чисел. Определите, сколько в нем
# встречается различных чисел.
# Input: [1, 1, 2, 0, -1, 3, 4, 4]
# Output: 6
'''''''''

lst_1 = [1, 1, 2, 0, -1, 3, 4, 4]
st = set(lst_1) # функция set показывает список только с уникальными значениями
print(len(st))


# inp = input().split() # разделяет числа, превращает их в список



######################################################



# Дана последовательность из N целых чисел и число
# K. Необходимо сдвинуть всю последовательность
# (сдвиг - циклический) на K элементов вправо, K –
# положительное число.
# Input: [1, 2, 3, 4, 5] k = 3
# Output: [4, 5, 1, 2, 3]


lst = [1, 2, 3, 4, 5]
lst1 = lst[0:3]
lst2 = lst[3:5]

print(lst1, lst2)
print(lst2 + lst1)

# 2 способ

k = 3
if k >= len(lst):
    k % len(lst)
lst1 = lst[:k]
lst2 = lst[k:]

print(lst1, lst2)
print(lst2 + lst1)


####################################################################


# Задача №21.
# Напишите программу для печати всех уникальных
# значений в словаре.
# Input: [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
# {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII
# ":" S007 "}]
# Output: {'S005', 'S002', 'S007', 'S001', 'S009'}


diction = [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"}, {"VI": "S005"}, {"VII": "S005"}, {"V":"S009"}, {"VIII":"S007"}]

st = set()
for d in diction:
    value = list(d.values())[0] # с кагого значения начинать, приводим к списку
    print(value)
    st.add(value)
print(st)


########################################################################################


# Задача №23.
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая подсчитает количество
# элементов массива, больших предыдущего (элемента
# с предыдущим номером)
# Input: [0, -1, 5, 2, 3]
# Output: 2 (-1 < 5, 2 < 3)
# Примечание: Пользователь может вводить значения
# списка или список задан изначально.

lst = [0, -1, 5, 2, 3]
count = 0
for i in range(1, len(lst)):
    if lst[i-1] < lst[i]:
        count += 1
print(count)


'''''''''

#################################################################
# Задача №39. Решение в группах
# Даны два массива чисел. Требуется вывести те элементы
# первого массива (в том порядке, в каком они идут в первом
# массиве), которых нет во втором массиве. Пользователь вводит
# число N - количество элементов в первом массиве, затем N
# чисел - элементы массива. Затем число M - количество
# элементов во втором массиве. Затем элементы второго массива

# Ввод:
# 7
# 3 1 3 4 2 4 12
# 6
# 4 15 43 1 15 1
# Вывод:
# 3 3 2 12
'''''''''
import random
a = int(input())
b = int(input())
lst_1 = [0]*a
lst_2 = [0]*b
answer = []

for i in range(a):
    lst_1[i] = random.randint(1, 10)
for i in range(b):
    lst_2[i] = random.randint(1, 10)
print(lst_1, lst_2)

for i in lst_1:
    if i not in lst_2:
        answer.append(i)
print(i, end=' ')

'''''''''

################################################
# Задача №41. Решение в группах
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.
# Ввод:
# 5
# 1 2 3 4 5
# Вывод:
# 0
# Ввод:
# 5
# 1 5 1 5 1
# Вывод:
# 2
'''''''''
import random
a = int(input())
lst_1 = [0]*a
count = 0
for i in range(a):
    lst_1[i] = random.randint(1, 10)
print(lst_1)

for i in range(1, len(lst_1) - 1):
    if lst_1[i] > lst_1[i + 1] and lst_1[i] > lst_1[i - 1]:
        count += 1
print(count)

'''''''''



###################################################################
# Задача №43. Решение в группах
# Дан список чисел. Посчитайте, сколько в нем пар
# элементов, равных друг другу. Считается, что любые
# два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать. Вводится список
# чисел. Все числа списка находятся на разных
# строках.
# Ввод:
# 1 2 3 2 3
# Вывод:
# 2
'''''''''
from collections import Counter # более оптимальный алгоритм

a = [1, 2, 3, 2, 3, 3]
count = 0
counter = dict(Counter(a)) # создаем словарь
print(counter)

for n in counter.values(): # ищем значения в словаре
    count += (n * (n - 1)) // 2
print(count)

'''''''''
# count = 0                     -------- более длинный вариант
# for i in range(len(a) - 1):
#     for j in range(i + 1, len(a)):
#         if a[i] == a[j]:
#             count += 1

# print(count)




##################################################################################
# Задача №45. Решение в группах
# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 105
# . Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).
# Ввод: Вывод:
# 300   220 284

def get_divisors_sum(number):  ### разложение на множители
    result = [1]
    for divisors in range(2, number // 2 + 1):
        if number % divisors == 0:
            result.append(divisors)
    return sum(result)

k = int(input())
st = set()

for number in range(k + 1):
    kandidat = get_divisors_sum(number)
    if get_divisors_sum(kandidat) == number and kandidat != number:
        st.add(tuple(sorted((number, kandidat))))

for a, b in st:
    print(a, b)



